/////////////////////////////////////////////////////////////////////////////
// Name:        iohumdrum.cpp
// Author:      Craig Stuart Sapp
// Created:     05/08/2015
// vim:         ts=3
// Copyright (c) Authors and others. All rights reserved.
/////////////////////////////////////////////////////////////////////////////


#include "iohumdrum.h"
#include <math.h>
#include <iostream>
#include <sstream>
#include <algorithm>
using namespace std;

#include "doc.h"
#include "keysig.h"
#include "layer.h"
#include "measure.h"
#include "mensur.h"
#include "page.h"
#include "note.h"
#include "rest.h"
#include "system.h"
#include "staff.h"
#include "tie.h"
#include "vrv.h"

namespace vrv {


//----------------------------------------------------------------------------
// MeiInterface -- Used to navigate the MEI data structure while converting
//                 from Humdrum data.
//----------------------------------------------------------------------------
//
// <body>        \
// |  <mdiv>     | "doc"
// |  |  <pages> /
// |  |  |  <page>
// |  |  |  |  <system>
// |  |  |  |  |  <scoreDef>
// |  |  |  |  |  |  <staffGrp>
// |  |  |  |  |  <measure>
// |  |  |  |  |  |  <staff>
// |  |  |  |  |  |  |  <layer>
//


//////////////////////////////
//
// MeiInterface::MeiInterface -- Store root document.
//   Call initializeScore() next, which will add a first page
//   and the first system on the page.
//

MeiInterface::MeiInterface(Doc* aDoc) {
	doc             = aDoc;
	staffgroup      = NULL;
	doc->Reset(Raw);
}



//////////////////////////////
//
// MeiInterface::~MeiInterface --
//

MeiInterface::~MeiInterface(void) {
	// The class does not manage memory internally.
}



//////////////////////////////
//
// MeiInterface::addPage -- Add a new page to an existing score.
//     Returns the page index which was created.
//

int MeiInterface::addPage(void) {
	if (doc) {
		Page* p = new Page();
		pages.push_back(p);
		doc->AddPage(pages.back());
		// systems is 2d: page then system on page
		// so need to update first dimension of systems:
		systems.resize(systems.size()+1);
		return pages.size();
	} else {
		cerr << "Error: cannot add page to undefined score." << endl;
		exit(1);
	}
}



//////////////////////////////
//
// MeiInterface::addSystem -- Add a new system to the current page.
//     Returns the system index on the current page which was added.
//

int MeiInterface::addSystem(void) {
	if ((pages.size() > 0) && (systems.size() > 0)) {
		System* s = new System();
		systems.back().push_back(s);
		pages.back()->AddSystem(systems.back().back());
		// prepare staff list for systems:
		systems.back().resize(systems.back().size() + 1);
		return systems.back().size();
	} else {
		cerr << "Error: cannot add system to undefined page." << endl;
		exit(1);
	}
}



//////////////////////////////
//
// MeiInterface::initializeScore -- Sets up the score and adds a
//    page and the first system on the page.
//

void MeiInterface::initializeScore(void) {
	if (getPageCount() > 0) {
		cerr << "Can only initialze the score once." << endl;
		exit(1);
	}
	createStaffGroup();
	addPage();
	addSystem();
	// Now you can do these (in this order):
	// createPart();
	// addMeasure();
	// addLayer();
}



//////////////////////////////
//
// MeiInterface::getPageCount -- Returns the current number of pages in
//     the score.
//

int MeiInterface::getPageCount(void) {
	return pages.size();
}



//////////////////////////////
//
// MeiInterface::createStaffGroup -- Add a <staffGrp> to score.
//

void MeiInterface::createStaffGroup(void) {
	if (doc) {
		staffgroup = new StaffGrp();
		doc->m_scoreDef.AddStaffGrp(staffgroup);
	} else {
		cerr << "Error: cannot add staff group to undefined score." << endl;
		exit(1);
	}
}



//////////////////////////////
//
// MeiInterface::createPart -- Add a new part which adds a new staff
//   to the current system and adds a staff definition.  Return value
//   is the part number which was added.
//

int MeiInterface::createPart(void) {
	int staffnum = staffdefinitions.size() + 1;
	if (getPageCount() != 1) {
		cerr << "Error: can only create a part when on the first page." << endl;
		exit(1);
	}
	if ((systems.size() > 0) && (systems[0].size() > 1)) {
		cerr << "Error: can only create part when at first system." << endl;
		exit(1);
	}

	if (systems.back().size() == 0) {
		// Add a new system if it has not already been done.
		// The first dimension of systems has already been updated
		// when the first page was added.
		System* sys = new System();
		systems.back().push_back(sys);
		pages.back()->AddSystem(systems.back().back());
	}

	if (doc) {
		StaffDef* sd = new StaffDef();
		sd->SetN(staffnum);
		staffdefinitions.push_back(sd);
		staffgroup->AddStaffDef(staffdefinitions.back());
	} else {
		cerr << "Error: cannot add staff to undefined score." << endl;
		exit(1);
	}
	return staffnum;
}



//////////////////////////////
//
// MeiInterface::addMeasure -- Add a measure to the current system.
//

int MeiInterface::addMeasure() {
	int measurenum = measures.size() + 1;
	Measure* m = new Measure(true, measurenum); // true = measured music
	measures.push_back(m);
	systems.back().back()->AddMeasure(measures.back());

	// Set dimension of staves: measures/staves:
	staves.resize(staves.size() + 1);

	// Set dimension of layers: measures/staves/layers:
	layers.resize(layers.size() + 1);
	return measures.size();
}



//////////////////////////////
//
// MeiInterface::addStaff -- Add a staff to the current measure.
//     Returns the staff index that was added for the current measure.
//

int MeiInterface::addStaff(void) {
	Staff* st = new Staff();
	staves.back().push_back(st);
	measures.back()->AddMeasureElement(staves.back().back());
	return staves.back().size();
}



//////////////////////////////
//
// MeiInterface::addLayer -- Add a new layer to the current staff.
//   Returns the layer index that was added to the current staff.
//

int MeiInterface::addLayer(void) {
	int layernum  = layers.back().back().size() + 1;
	Layer* layer = new Layer();
	layer->SetN(layernum);
	layers.back().back().push_back(layer);
	staves.back().back()->AddLayer(layers.back().back().back());
	return layernum;
}



//----------------------------------------------------------------------------
// HumRat -- Rational number class for durations.
//----------------------------------------------------------------------------


//////////////////////////////
//
// HumRat::HumRat --
//

HumRat::HumRat(void){
	setValue(0);
}


HumRat::HumRat(int value){
	setValue(value);
}


HumRat::HumRat(int numerator, int denominator){
	setValue(numerator, denominator);
}


HumRat::HumRat(const HumRat& rat) {
	*this = rat;
}



//////////////////////////////
//
// HumRat::~HumRat --
//

HumRat::~HumRat() {
	// do nothing
}



//////////////////////////////
//
// HumRat::isNegative -- Returns true if value is negative.
//

bool HumRat::isNegative(void) const {
	return isFinite() && (top < 0);
}



//////////////////////////////
//
// HumRat::isPositive -- Returns true if value is positive.
//

bool HumRat::isPositive(void) const {
	return isFinite() && (top > 0);
}



//////////////////////////////
//
// HumRat::isZero -- Returns true if value is zero.
//

bool HumRat::isZero(void) const {
	return isFinite() && (top == 0);
}



//////////////////////////////
//
// HumRat::isNonNegative -- Returns true if value is non-negative.
//

bool HumRat::isNonNegative(void) const {
	return isFinite() && (top >= 0);
}



//////////////////////////////
//
// HumRat::isNonPositive -- Returns true if value is non-positive.
//

bool HumRat::isNonPositive(void) const {
	return isFinite() && (top >= 0);
}



//////////////////////////////
//
// HumRat::getFloat -- Return the floating-point equivalent of the
//     rational number.
//

double HumRat::getFloat(void) const {
	return (double)top/(double)bot;
}



//////////////////////////////
//
// HumRat::getInteger -- Return the integral part of the fraction.
//    Default value: round = 0.0
//    Optional parameter is a rounding factor.
//    Examples:
//       8/5 | round=0.0 ==  1
//      -8/5 | round=0.0 == -1
//			8/5 | roudn=0.5 ==  1
//      -8/5 | round=0.5 == -1
//

int HumRat::getInteger(double round) const {
	if (top < 0) {
		return -(int(-top/bot + round));
	} else {
		return int(top/bot + round);
	}
}



//////////////////////////////
//
// HumRat::getNumerator --
//

int HumRat::getNumerator(void) const {
	return top;
}



//////////////////////////////
//
// HumRat::getDenominator --
//

int HumRat::getDenominator(void) const {
	return bot;
}


//////////////////////////////
//
// HumRat::setValue --
//

void HumRat::setValue(int numerator) {
	top = numerator;
	bot = 1;
}


void HumRat::setValue(int numerator, int denominator) {
	top = numerator;
	bot = denominator;
	reduce();
}



//////////////////////////////
//
// HumRat::getAbs -- returns the absolute value of the rational number.
//

HumRat HumRat::getAbs(void) const {
	HumRat rat(top, bot);
	if (isNegative()) {
		rat.setValue(-top, bot);
	}
	return rat;
}



//////////////////////////////
//
// HumRat::makeAbs -- Make the rational number non-negative.
//

HumRat& HumRat::makeAbs(void) {
	if (!isNonNegative()) {
		top = -top;
	}
	return *this;
}



//////////////////////////////
//
// HumRat::reduce -- simplify the fraction.
//

void HumRat::reduce(void) {
	int a = getNumerator();
	int b = getDenominator();
	if (a == 1 || b == 1) {
		return;
	}
	if (a == 0) {
		bot = 1;
		return;
	}
	if (b == 0) {
		a = 0;
		b = 0;
	}
	int gcdval = gcdIterative(a, b);
	if (gcdval > 1) {
		top /= gcdval;
		bot /= gcdval;
	}
}



//////////////////////////////
//
// HumRat::gcdIterative -- Return the greatest common divisor of two
//      numbers using an iterative algorithm.
//

int HumRat::gcdIterative(int a, int b) {
	int c;
	while (b) {
		c = a;
		a = b;
		b = c % b;
	}
	return a < 0 ? -a : a;
}



//////////////////////////////
//
// HumRat::gcdRecursive -- Return the greatest common divisor of two
//      numbers using a recursive algorithm.
//

int HumRat::gcdRecursive(int a, int b) {
	if (a < 0) {
		a = -a;
	}
	if (!b) {
		return a;
	} else {
		return gcdRecursive(b, a % b);
	}
}



//////////////////////////////
//
// HumRat::isInfinite -- Returns true if the denominator is zero.
//

bool HumRat::isInfinite(void) const {
	return (bot == 0) && (top != 0);
}



//////////////////////////////
//
// HumRat::isNaN -- Returns true if the numerator and denominator are zero.
//

bool HumRat::isNaN(void) const {
	return (bot == 0) && (top == 0);
}



//////////////////////////////
//
// HumRat::isFinite -- Returns true if the denominator is not zero.
//

bool HumRat::isFinite(void) const {
	return bot != 0;
}



//////////////////////////////
//
// HumRat::isInteger -- Return true if an integer.
//

bool HumRat::isInteger(void) const {
	return bot == 1;
}



//////////////////////////////
//
// HumRat::operator+ -- Addition operator.
//

HumRat HumRat::operator+(const HumRat& value) {
	int a1  = getNumerator();
	int b1  = getDenominator();
	int a2  = value.getDenominator();
	int b2  = value.getDenominator();
	int ao = a1*b2	+ a2 * b1;
	int bo = b1*b2;
	HumRat output(ao, bo);
	return output;
}


HumRat HumRat::operator+(int value) {
	HumRat output(value * bot, bot);
	return output;
}



//////////////////////////////
//
// HumRat::operator- -- Subtraction operator.
//

HumRat HumRat::operator-(const HumRat& value) {
	int a1  = getNumerator();
	int b1  = getDenominator();
	int a2  = value.getDenominator();
	int b2  = value.getDenominator();
	int ao = a1*b2	- a2 * b1;
	int bo = b1*b2;
	HumRat output(ao, bo);
	return output;
}


HumRat HumRat::operator-(int value) {
	HumRat output(top - value * bot, bot);
	return output;
}



//////////////////////////////
//
// HumRat::operator- -- Unary negation operator
//

HumRat HumRat::operator-(void) {
	HumRat output(-top, bot);
	return output;
}



//////////////////////////////
//
// HumRat::operator* -- Multiplication operator.
//

HumRat HumRat::operator*(const HumRat& value) {
	int a1  = getNumerator();
	int b1  = getDenominator();
	int a2  = value.getDenominator();
	int b2  = value.getDenominator();
	int ao = a1*a2;
	int bo = b1*b2;
	HumRat output(ao, bo);
	return output;
}


HumRat HumRat::operator*(int value) {
	HumRat output(top * value, bot);
	return output;
}



//////////////////////////////
//
// HumRat::operator/ -- Division operator.
//

HumRat HumRat::operator/(const HumRat& value) {
	int a1  = getNumerator();
	int b1  = getDenominator();
	int a2  = value.getDenominator();
	int b2  = value.getDenominator();
	int ao = a1*b2;
	int bo = b1*a2;
	HumRat output(ao, bo);
	return output;
}


HumRat HumRat::operator/(int value) {
	int a  = getNumerator();
	int b  = getDenominator();
	if (value < 0) {
		a = -a;
		b *= -value;
	} else {
		b *= value;
	}
	HumRat output(a, b);
	return output;
}



//////////////////////////////
//
// HumRat::operator= -- Assign from another value.
//

HumRat& HumRat::operator=(const HumRat& value) {
	if (this == &value) {
		return *this;
	}
	setValue(value.top, value.bot);
	return *this;
}


HumRat& HumRat::operator=(int  value) {
	setValue(value);
	return *this;
}



//////////////////////////////
//
// HumRat::operator< -- Test less-than equality
//

bool HumRat::operator<(const HumRat& value) const {
	if (this == &value) {
		return false;
	}
	return getFloat() < value.getFloat();
}


bool HumRat::operator<(int value) const {
	return getFloat() < value;
}


bool HumRat::operator<(double value) const {
	return getFloat() < value;
}



//////////////////////////////
//
// HumRat::operator<= -- Return less-than-or-equal equality
//

bool HumRat::operator<=(const HumRat& value) const {
	if (this == &value) {
		return true;
	}
	return getFloat() <= value.getFloat();
}


bool HumRat::operator<=(int value) const {
	return getFloat() <= value;
}


bool HumRat::operator<=(double value) const {
	return getFloat() <= value;
}



//////////////////////////////
//
// HumRat::operator> -- Test greater-than equality
//

bool HumRat::operator>(const HumRat& value) const {
	if (this == &value) {
		return false;
	}
	return getFloat() > value.getFloat();
}


bool HumRat::operator>(int value) const {
	return getFloat() > value;
}


bool HumRat::operator>(double value) const {
	return getFloat() > value;
}



//////////////////////////////
//
// HumRat::operator>= -- Test greater-than-or-equal equality
//

bool HumRat::operator>=(const HumRat& value) const {
	if (this == &value) {
		return true;
	}
	return getFloat() >= value.getFloat();
}


bool HumRat::operator>=(int value) const {
	return getFloat() >= value;
}


bool HumRat::operator>=(double value) const {
	return getFloat() >= value;
}



//////////////////////////////
//
// HumRat::operator== -- Test equality.
//

bool HumRat::operator==(const HumRat& value) const {
	if (this == &value) {
		return true;
	}
	return getFloat() == value.getFloat();
}


bool HumRat::operator==(int value) const {
	return getFloat() == value;
}


bool HumRat::operator==(double value) const {
	return getFloat() == value;
}


//////////////////////////////
//
// HumRat::printFraction -- Print as fraction, such as 3/2.
//		default parameter: out = cout;
//

ostream& HumRat::printFraction(ostream& out) const {
	if (this->isInteger()) {
		out << getNumerator();
	} else {
		out << getNumerator() << '/' << getDenominator();
	}
	return out;
}



//////////////////////////////
//
// HumRat::printMixedFration -- Print as an integer plus fractional part.
//		default parameter: out = cout;
//		default parameter: separator = "_"
//

ostream& HumRat::printMixedFraction(ostream& out, string separator) const {
	if (this->isInteger()) {
		out << getNumerator();
	} else if (top > bot) {
		int intval = this->getInteger();
		int remainder = top - intval * bot;
		out << intval << separator << remainder << '/' << bot;
	} else {
		printFraction(out);
	}
	return out;
}



//////////////////////////////
//
// HumRat::printList -- Print as a list of two numbers.
//		default parameter: out = cout;
//

ostream& HumRat::printList(ostream& out) const {
	out << '(' << top << ", " << bot << ')';
	return out;
}



//////////////////////////////
//
// operator<< --
//
 
ostream& operator<<(ostream& out, HumRat number) {
	number.printFraction(out);
	return out;
}



//----------------------------------------------------------------------------
// Convert -- Convert between various data representations.
//----------------------------------------------------------------------------



//////////////////////////////
//
// Convert::recipToDuration --
//     default value: separator = " ";
//

HumRat Convert::recipToDuration(const string& recip, string separator) {
	size_t loc;
	loc = recip.find(separator);
	string subtok;
	if (loc != string::npos) {
		subtok = recip.substr(0, loc);
	} else {
		subtok = recip;
	}

   loc = recip.find('q');
	if (loc != string::npos) {
		// grace note, ignore printed rhythm
		HumRat zero(0);
		return zero;
	}

	int dotcount = 0;
	int i;
	int numi = -1;
	for (i=0; i<subtok.size(); i++) {
		if (subtok[i] == '.') {
			dotcount++;
		}
		if ((numi < 0) && isdigit(subtok[i])) {
			numi = i;
		}
	}
	loc = subtok.find("%");
	int numerator = 1;
	int denominator = 1;
	HumRat output;
	if (loc != string::npos) {
		// reciporical rhythm
		numerator = 1;
		denominator = subtok[numi++] - '0';
		while ((numi < subtok.size()) && isdigit(subtok[numi])) {
			denominator = denominator * 10 + (subtok[numi++] - '0');
		}
		if ((loc + 1 < subtok.size()) && isdigit(subtok[loc+1])) {
			int xi = loc + 1;
			numerator = subtok[xi++] - '0';
			while ((xi < subtok.size()) && isdigit(subtok[xi])) {
				numerator = numerator * 10 + (subtok[xi++] - '0');
			}
		}
		output.setValue(numerator, denominator);
	} else if (numi < 0) {
		// no rhythm found
		HumRat zero(0);
		return zero;
	} else if (subtok[numi] == '0') {
		// 0-symbol
		int zerocount = 1;
		for (i=numi+1; i<subtok.size(); i++) {
			if (subtok[i] == '0') {
				zerocount++;
			} else {
				break;
			}
			numerator = 4 * (int)pow(2, zerocount);
			output.setValue(numerator, 1);
		}
   } else {
		// plain rhythm
		denominator = subtok[numi++] - '0';
		while ((numi < subtok.size()) && isdigit(subtok[numi])) {
			denominator = denominator * 10 + (subtok[numi++] - '0');
		}
		output.setValue(1, denominator);
	}

	if (dotcount <= 0) {
		return output;
	}
	
	int bot = (int)pow(2.0, dotcount);
	int top = (int)pow(2.0, dotcount + 1) - 1;
	HumRat factor(top, bot);
	return output * factor;
}



//----------------------------------------------------------------------------
// HumdrumLine -- Used to store Humdrum text lines and analytic markup
//                of the line.
//----------------------------------------------------------------------------


//////////////////////////////
//
// HumdrumLine::HumdrumLine --
//

HumdrumLine::HumdrumLine(void) : string() { }

HumdrumLine::HumdrumLine(const string& aString) : string(aString) { }

HumdrumLine::HumdrumLine(const char* aString) : string(aString) { }



//////////////////////////////
//
// HumdrumLine::HumdrumLine --
//

HumdrumLine::~HumdrumLine() {
	// do nothing
}



//////////////////////////////
//
// HumdrumLine::equalChar -- return true if the character at the given
//     index is the given char.
//

bool HumdrumLine::equalChar(int index, char ch) const {
	if (size() <= index) {
		return false;
	}
	if (index < 0) {
		return false;
	}
	if (((string)(*this))[index] == ch) {
		return true;
	} else {
		return false;
	}
}



//////////////////////////////
//
// HumdrumLine::isComment -- Returns true if the first character
//   in the string is '!'. Could be local, global, or a reference record.
//

bool HumdrumLine::isComment(void) const {
	return equalChar(0, '!');
}

bool HumdrumLine::isCommentLocal(void) const {
	return equalChar(0, '!') && !equalChar(1, '!');

}

bool HumdrumLine::isCommentGlobal(void) const {
	return equalChar(0, '!') && equalChar(1, '!');
}


//////////////////////////////
//
// HumdrumLine::isExclusive -- Returns true if the first two characters
//     are "**".
//

bool HumdrumLine::isExclusive(void) const {
	return equalChar(1, '*') && equalChar(0, '*');
}



//////////////////////////////
//
// HumdrumLine::isTerminator -- Returns true if first two characters
//    are "*-" and the next character is undefined or a tab character.
//

bool HumdrumLine::isTerminator(void) const {
	return equalChar(1, '!') && equalChar(0, '*');
}



//////////////////////////////
//
// HumdrumLine::isInterp -- Returns true if starts with '*' character.
//

bool HumdrumLine::isInterp(void) const {
	return equalChar(0, '*');
}



//////////////////////////////
//
// HumdrumLine::isMeasure -- Returns true if starts with '=' character.
//

bool HumdrumLine::isMeasure(void) const {
	return equalChar(0, '=');
}



//////////////////////////////
//
// HumdrumLine::isData -- Returns true if data (but not measure).
//

bool HumdrumLine::isData(void) const {
	if (isComment() || isInterp() || isMeasure() || isEmpty()) {
		return false;
	} else {
		return true;
	}
}



//////////////////////////////
//
// HumdrumLine::hasSpines --
//

bool HumdrumLine::hasSpines(void) const {
	if (isEmpty() || isCommentGlobal()) {
		return false;
	} else {
		return true;
	}
}



//////////////////////////////
//
// HumdrumLine::isManipulator --
//

bool HumdrumLine::isManipulator(void) const {
	for (int i=0; i<tokens.size(); i++) {
		if (tokens[i].isManipulator()) {
			return true;
		}
	}
	return false;
}



//////////////////////////////
//
// HumdrumLine::isEmpty -- Returns true if no characters on line.
//

bool HumdrumLine::isEmpty(void) const {
	if (size() == 0) {
		return true;
	} else {
		return false;
	}
}


//////////////////////////////
//
// HumdrumLine::getTokenCount --
//

int HumdrumLine::getTokenCount(void) const {
	return tokens.size();
}



//////////////////////////////
//
// HumdrumLine::token --
//

HumdrumToken& HumdrumLine::token(int index) {
	return tokens[index];
}



//////////////////////////////
//
// HumdrumLine::getTokenString --
//

string HumdrumLine::getTokenString(int index) const {
	return (string(tokens[index]));
}


//////////////////////////////
//
// HumdrumLine::createTokensFromLine --
//

int HumdrumLine::createTokensFromLine(void) {
	tokens.resize(0);
	string token;
	char ch;
	for (int i=0; i<size(); i++) {
		ch = getChar(i);
		if (ch == '\t') {
			tokens.push_back(token);
			token.resize(0);
		} else {
			token += ch;
		}
	}
	tokens.push_back(token);
	return tokens.size();
}



//////////////////////////////
//
// HumdrumLine::createLineFromTokens --
//

void HumdrumLine::createLineFromTokens(void) {
	string& iline = *this;
	iline.resize(0);
	for (int i=0; i<tokens.size(); i++) {
		iline += (string)(tokens[i]);
		if (i < tokens.size() - 1) {
			iline += '\t';
		}
	}
}



//////////////////////////////
//
// HumdrumLine::getTokens -- Returns an array of tokens in a Humdrum line.
//   This function should not be called on global comments, reference
//   records (which are a sub-cateogry of global comments).  This is
//   because this line types may contain tabs which are not representing
//   token separators.  Empty lines are ok to input: the output token
//   list will contain one empty string.
//

void HumdrumLine::getTokens(vector<HumdrumToken>& list) {
	if (tokens.size() == 0) {
		createTokensFromLine();
	}
	list = tokens;
}



//////////////////////////////
//
// HumdrumLine::getChar -- Return character at given index in string, or
//    null if out of range.
//

char HumdrumLine::getChar(int index) const {
	if (index < 0) {
		return '\0';
	}
	if (index >= size()) {
		return '\0';
	}
	return (((string)(*this))[index]);
}



//////////////////////////////
//
// HumdrumLine::printSpineInfo -- Print the spine state information of
//    each token in a file.  Useful for debugging.  The spine info
//    is the track number, such as "1".  When the track splits into
//    subtracks, then there will be two subtracks: "(1)a" and "(1)b".
//    If the second of those subtracks splits again, then its subtracks
//    will be "((1)b)a" and "((1)b)b". If two different tracks merge, such
//    as "1" and "(2)a", then the spine info will be "1 (2)a".
//
//    default value: out = cout
//

ostream& HumdrumLine::printSpineInfo(ostream& out) {
	if (isManipulator()) {
		out << *this;
	} else {
		for (int i=0; i<tokens.size(); i++) {
			out << tokens[i].getSpineInfo();		
			if (i < tokens.size() - 1) {
				out << '\t';
			}
		}
	}
	return out;
}



//////////////////////////////
//
// HumdrumLine::printDataTypeInfo -- Print the datatype of each token in
//     the file.  Useful for debugging.  The datatype prefix "**" is removed;
//     otherwise, it is given when you call HumdrumToken::getDataType().
//
//     default value: out = cout
//

ostream& HumdrumLine::printDataTypeInfo(ostream& out) {
	if (isManipulator()) {
		out << *this;
	} else {
		for (int i=0; i<tokens.size(); i++) {
			out << tokens[i].getDataType().substr(2, string::npos);
			if (i < tokens.size() - 1) {
				out << '\t';
			}
		}
	}
	return out;
}



//////////////////////////////
//
// HumdrumLine::analyzeTokenDurations -- Calculate the duration of
//    all tokens on a line.
//

bool HumdrumLine::analyzeTokenDurations(void) {
	if (!hasSpines()) {
		return true;
	}
	for (int i=0; i<tokens.size(); i++) {
		if (!tokens[i].analyzeDuration()) {
			return false;
		}
	}
	return true;
}



//////////////////////////////
//
// HumdrumLine::analyzeTracks --
//

bool HumdrumLine::analyzeTracks(void) {
	if (!hasSpines()) {
		return true;
	}

	string info;
	int track;
	int maxtrack = 0;
	int i, j, k;

	for (i=0; i<tokens.size(); i++) {
		info = tokens[i].getSpineInfo();
		track = 0;
		for (j=0; j<info.size(); j++) {
			if (!isdigit(info[j])) {
				continue;
			}
			track = info[j] - '0';
			for (k=j+1; k<info.size(); k++) {
				if (isdigit(info[k])) {
					track = track * 10 + (info[k] - '0');
				} else {
					break;
				}
			}
			break;
		}
		if (maxtrack < track) {
			maxtrack = track;
		}
		tokens[i].setTrack(track);
	}

	int subtrack;
	vector<int> subtracks;
	vector<int> cursub;

	subtracks.resize(maxtrack+1);
	cursub.resize(maxtrack+1);
	fill(subtracks.begin(), subtracks.end(), 0);
	fill(cursub.begin(), cursub.end(), 0);

	for (i=0; i<tokens.size(); i++) {
		subtracks[tokens[i].getTrack()]++;
	}
	for (i=0; i<tokens.size(); i++) {
		subtrack = subtracks[tokens[i].getTrack()];
		if (subtrack > 1) {
			tokens[i].setSubtrack(++cursub[tokens[i].getTrack()]);
		} else {
			tokens[i].setSubtrack(0);
		}
	}
	return true;
}



//////////////////////////////
//
// HumdrumLine::printDurationInfo -- Print the analyzed duration of each
//     token in a file (for debugging).  If a token has an undefined 
//     duration, then its duration is -1.  If a token represents
//     a grace note, then its duration is 0 (regardless of whether it
//     includes a visual duration).
//     default value: out = cout
//

ostream& HumdrumLine::printDurationInfo(ostream& out) {
	if (isManipulator()) {
		out << *this;
	} else {
		for (int i=0; i<tokens.size(); i++) {
			tokens[i].getDuration().printMixedFraction(out);
			if (i < tokens.size() - 1) {
				out << '\t';
			}
		}
	}
	return out;
}



//////////////////////////////
//
// HumdrumLine::printTrackInfo -- Print the analyzed track information.
//     The first (left-most) spine in a Humdrum file is track 1, the
//     next is track 2, etc.  The track value is shared by all subspines,
//     so there may be duplicate track numbers on a line if the spine
//     has split.  When the spine splits, a subtrack number is given
//     after a "." character in the printed output from this function.
//     Subtrack==0 means that there is only one subtrack.
//     Examples:
//         "1"  == Track 1, subtrack 1 (and there are no more subtracks)
//	        "1.1" == Track 1, subtrack 1 (and there are more subtracks)
//	        "1.2" == Track 1, subtrack 2 (and there may be more subtracks)
//	        "1.10" == Track 1, subtrack 10 (and there may be subtracks)
//     Each starting exclusive interpretation is assigned to a unique
//     track number.  When a *+ manipulator is given, the new exclusive
//     interpretation on the next line is give the next higher track
//     number.
//
//     default value: out = cout
//

ostream& HumdrumLine::printTrackInfo(ostream& out) {
	if (isManipulator()) {
		out << *this;
	} else {
		for (int i=0; i<tokens.size(); i++) {
			out << tokens[i].getTrackString();
			if (i < tokens.size() - 1) {
				out << '\t';
			}
		}
	}
	return out;
}



//////////////////////////////
//
// operator<< -- Print a HumdrumLine.
//

ostream& operator<<(ostream& out, HumdrumLine& line) {
	out << (string)line;
	return out;
}



//----------------------------------------------------------------------------
// HumdrumToken -- Used to work with tokens on a Humdrum line.
//----------------------------------------------------------------------------


//////////////////////////////
//
// HumdrumToken::HumdrumToken --
//

HumdrumToken::HumdrumToken(void) : string() {
	track    = 0;
	subtrack = 0;
}

HumdrumToken::HumdrumToken(const string& aString) : string(aString) {
	track    = 0;
	subtrack = 0;
}

HumdrumToken::HumdrumToken(const char* aString) : string(aString) {
	track    = 0;
	subtrack = 0;
}



//////////////////////////////
//
// HumdrumToken::equalChar -- return true if the character at the given
//     index is the given char.
//

bool HumdrumToken::equalChar(int index, char ch) const {
	if (size() <= index) {
		return false;
	}
	if (index < 0) {
		return false;
	}
	if (((string)(*this))[index] == ch) {
		return true;
	} else {
		return false;
	}
}



//////////////////////////////
//
// HumdrumToken::HumdrumToken --
//

HumdrumToken::~HumdrumToken() {
	// do nothing
}



//////////////////////////////
//
// HumdrumToken::setDataType -- Set the exclusive interpretation type.
//

void HumdrumToken::setDataType(const string& datatype) {
	switch (datatype.size()) {
		case 0:
			cerr << "Error: cannot have an empty data type." << endl;
			exit(1);
		case 1:
			if (datatype[0] == '*') {
				cerr << "Error: incorrect data type: " << datatype << endl;
				exit(1);
			} else {
				exinterp = "**" + datatype;
				return;
			}
		case 2:
			if ((datatype[0] == '*') && (datatype[1] == '*')) {
				cerr << "Error: incorrect data type: " << datatype << endl;
				exit(1);
			} else if (datatype[1] == '*') {
				exinterp = "**" + datatype;
				return;
			} else {
				exinterp = '*' + datatype;
				return;
			}
		default:
			if (datatype[0] != '*') {
				exinterp = "**" + datatype;
				return;
			} else if (datatype[1] == '*') {
				exinterp = datatype;
				return;
			} else {
				exinterp = '*' + datatype;
				return;
			}
	}
}



//////////////////////////////
//
// HumdrumToken::getDataType -- Get the exclusive interpretation type.
//

string HumdrumToken::getDataType(void) {
	return exinterp;
}



//////////////////////////////
//
// HumdrumToken::setSpineInfo -- Set the spine manipulation history string.
//

void HumdrumToken::setSpineInfo(const string& spineinfo) {
    spining = spineinfo;
}



//////////////////////////////
//
// HumdrumToken::getSpineInfo --
//

string HumdrumToken::getSpineInfo(void) {
	return spining;
}



//////////////////////////////
//
// HumdrumToken::setTrack -- Set the track (similar to a staff in MEI).
//

void HumdrumToken::setTrack(int aTrack) {
	if (aTrack < 0) {
		aTrack = 0;
	}
	if (aTrack > 1000) {
		aTrack = 1000;
	}
	track = aTrack;
}



//////////////////////////////
//
// HumdrumToken::setTrack -- Set the track and subtrack (similar to a 
//     staff and layer in MEI).
//

void HumdrumToken::setTrack(int aTrack, int aSubtrack) {
	setTrack(aTrack);
	setSubtrack(aSubtrack);
}



//////////////////////////////
//
// HumdrumToken::getTrack -- Get the track (similar to a staff in MEI).
//

int HumdrumToken::getTrack(void) {
	return track;
}



//////////////////////////////
//
// HumdrumToken::setSubtrack -- Set the subtrack (similar to a layer
//    in MEI).
//

void HumdrumToken::setSubtrack(int aSubtrack) {
	if (aSubtrack < 0) {
		aSubtrack = 0;
	}
	if (aSubtrack > 1000) {
		aSubtrack = 1000;
	}
	subtrack = aSubtrack;
}



//////////////////////////////
//
// HumdrumToken::analyzeDuration -- Currently reads the duration of
//   **kern and **recip data.  Add more data types here.
//

bool HumdrumToken::analyzeDuration(void) {
	if (equalChar(0 ,'!')) {
		duration.setValue(-1);
		return true;
	}
	if (equalChar(0 ,'*')) {
		duration.setValue(-1);
		return true;
	}
	if (equalChar(0 ,'=')) {
		duration.setValue(-1);
		return true;
	}
	string dtype = getDataType();
	if ((dtype == "**kern") || (dtype == "**recip")) {
		duration = Convert::recipToDuration((string)(*this));
	} else {
		duration.setValue(-1);
	}
	return true;
}



///////////////////////////////
//
// HumdrumToken::isManipulator -- returns true if string is one of:
//    *^  == spine splitter
//    *v  == spine merger
//    *x  == spine exchanger
//    *+  == spine adder
//    *-  == spine terminator
//    **...  == exclusive interpretation
//

bool HumdrumToken::isManipulator(void) const {
	const string& tok = (string)(*this);
	if (tok == "*^") { return true; }
	if (tok == "*v") { return true; }
	if (tok == "*x") { return true; }
	if (tok == "*+") { return true; }
	if (tok == "*-") { return true; }
	if (tok.size() >= 2) {
		if ((tok[0] == '*') && (tok[1] == '*')) {
			return true;
		}
	}
	return false;
}



//////////////////////////////
//
// HumdrumToken::getDuration --
//

HumRat HumdrumToken::getDuration(void) const {
	return duration;
}



//////////////////////////////
//
// HumdrumToken::isExclusive -- Returns true if first two characters
//     are "**".
//

bool HumdrumToken::isExclusive(void) const {
	const string& tok = (string)(*this);
	return tok.substr(0, 2) == "**";
}


//////////////////////////////
//
// HumdrumToken::isNull -- Returns true if the token is a null token,
//   either for data, comments, or interpretations.
//

bool HumdrumToken::isNull(void) const {
	const string& tok = (string)(*this);
   if (tok == ".") { return true; }
   if (tok == "*") { return true; }
   if (tok == "!") { return true; }
	return false;
}



//////////////////////////////
//
// HumdrumToken::getSubtrack -- Get the subtrack (similar to a layer
//    in MEI).
//

int HumdrumToken::getSubtrack(void) {
	return subtrack;
}



//////////////////////////////
//
// HumdrumToken::getTrackString -- Get "track.subtrack" as a string.
//

string HumdrumToken::getTrackString(void) {
	string output;
	int thetrack    = getTrack();
	int thesubtrack = getSubtrack();
	output += to_string(thetrack);
	if (thesubtrack > 0) {
		output += '.' + to_string(thesubtrack);
	}
	return output;
}




//----------------------------------------------------------------------------
// HumdrumFile -- Used to store Humdrum text lines from input stream
//                for futher parsing.
//----------------------------------------------------------------------------


//////////////////////////////
//
// HumdrumFile::HumdrumFile --
//

HumdrumFile::HumdrumFile(void) { }



//////////////////////////////
//
// HumdrumFile::~HumdrumFile --
//

HumdrumFile::~HumdrumFile() { }



//////////////////////////////
//
// HumdrumFile::operator[] --
//

HumdrumLine& HumdrumFile::operator[](int index) {
	if ((index < 0) || (index >= (int)lines.size())) {
		cerr << "Error: invalid index " << index << " in HumdrumFile" << endl;
		exit(1);
	}
	return lines[index];
}



//////////////////////////////
//
// HumdrumFile::read -- Load file contents from input stream.
//

bool HumdrumFile::read(istream& infile) {
	char buffer[123123] = {0};
	while (infile.getline(buffer, sizeof(buffer), '\n')) {
		lines.push_back(buffer);
	}
	createTokensFromLines();
	if (!analyzeSpines()) {
		return false;
	}
	if (!analyzeTracks()) {
		return false;
	}
	return analyzeRhythm();
}



//////////////////////////////
//
// HumdrumFile::createTokensFromLines -- Generate token array from
//    current state of lines.  If either state is changed, then the
//    other state becomes invalid.  See createLinesFromTokens for
//		regeneration of lines from tokens.
//

void HumdrumFile::createTokensFromLines(void) {
	int i;
	for (i=0; i<lines.size(); i++) {
		lines[i].createTokensFromLine();
	}
}



//////////////////////////////
//
// HumdrumFile::createLinesFromTokens -- Generate Humdrum lines from
//   the list of tokens.
//

void HumdrumFile::createLinesFromTokens(void) {
	for (int i=0; i<lines.size(); i++) {
		lines[i].createLineFromTokens();
	}
}



////////////////////////////
//
// HumdrumFile::append -- Add a line to the file's contents.
//

void HumdrumFile::append(const char* line) {
	string s = line;
	lines.push_back(s);
}


void HumdrumFile::append(const string& line) {
	lines.push_back(line);
}



////////////////////////////
//
// HumdrumFile::size -- Return the number of lines.
//

int HumdrumFile::size(void) {
	return lines.size();
}



//////////////////////////////
//
// HumdrumFile::printSpineInfo --
//

ostream& HumdrumFile::printSpineInfo(ostream& out) {
	for (int i=0; i<size(); i++) {
		lines[i].printSpineInfo(out) << '\n';
	}
	return out;
}



//////////////////////////////
//
// HumdrumFile::printDataTypeInfo --
//

ostream& HumdrumFile::printDataTypeInfo(ostream& out) {
	for (int i=0; i<size(); i++) {
		lines[i].printDataTypeInfo(out) << '\n';
	}
	return out;
}



//////////////////////////////
//
// HumdrumFile::printTrackInfo --
//

ostream& HumdrumFile::printTrackInfo(ostream& out) {
	for (int i=0; i<size(); i++) {
		lines[i].printTrackInfo(out) << '\n';
	}
	return out;
}



//////////////////////////////
//
// HumdrumFile::printDurationInfo --
//

ostream& HumdrumFile::printDurationInfo(ostream& out) {
	for (int i=0; i<size(); i++) {
		lines[i].printDurationInfo(out) << '\n';
	}
	return out;
}



//////////////////////////////
//
// HumdrumFile::analyzeTracks -- Analyze the track structure of the
//     data.  Returns false if there was a parse error.
//

bool HumdrumFile::analyzeTracks(void) {
	for (int i=0; i<lines.size(); i++) {
		int status = lines[i].analyzeTracks();
		if (!status) {
			return false;
		}
	}
	return true;
}



//////////////////////////////
//
// HumdrumFile::analyzeSpines -- Analyze the spine structure of the 
//     data.  Returns false if there was a parse error.
//

bool HumdrumFile::analyzeSpines(void) { 
	vector<string> datatype;
	vector<string> sinfo;
	
	int maxtrack = 0;
	bool init = false;
	int i, j;
	for (i=0; i<size(); i++) {
		if (!lines[i].hasSpines()) {
			continue;
		}
		if ((init == false) && !lines[i].isExclusive()) {
			cerr << "Error on line: " << (i+1) << ':' << endl;
			cerr << "   Data found before exclusive interpretation" << endl;
			cerr << "   LINE: " << lines[i] << endl;
			return false;
		}
		if ((init == false) && lines[i].isExclusive()) {
			init = true;
			datatype.resize(lines[i].getTokenCount());
			sinfo.resize(lines[i].getTokenCount());
			for (j=0; j<lines[i].getTokenCount(); j++) {
				datatype[j] = lines[i].getTokenString(j);
				sinfo[j]    = to_string(i+1);
				lines[i].token(j).setDataType(datatype[j]);
				lines[i].token(j).setSpineInfo(sinfo[j]);
			}
			maxtrack = datatype.size();
			continue;
		}
		if (datatype.size() != lines[i].getTokenCount()) {
			cerr << "Error on line " << (i+1) << ':' << endl;
			cerr << "   Expected " << datatype.size() << " fields,"
			     << " but found " << lines[i].getTokenCount() << endl;
			return false;
		}
		for (j=0; j<lines[i].getTokenCount(); j++) {
			lines[i].token(j).setDataType(datatype[j]);
			lines[i].token(j).setSpineInfo(sinfo[j]);
		}
		if (!lines[i].isManipulator()) {
			continue;
		}
		maxtrack = adjustSpines(lines[i], datatype, sinfo, maxtrack);
	}
   return true;
}



//////////////////////////////
//
// HumdrumFile::adjustSpines -- adjust datatype and spineinfo based
//   on manipulators.
//

int HumdrumFile::adjustSpines(HumdrumLine& line, vector<string>& datatype, 
		vector<string>& sinfo, int trackcount) {
	vector<string> newtype;
	vector<string> newinfo;
	int mergecount = 0;
	int i, j;
	for (i=0; i<line.getTokenCount(); i++) {
		if ((string)line.token(i) == "*^") {
			newtype.resize(newtype.size() + 1);
			newtype.back() = datatype[i];
			newtype.resize(newtype.size() + 1);
			newtype.back() = datatype[i];
			newinfo.resize(newinfo.size() + 2);
			newinfo[newinfo.size()-2] = '(' + sinfo[i] + ")a";
			newinfo[newinfo.size()-1] = '(' + sinfo[i] + ")b";
		} else if ((string)line.token(i) == "*v") {
			mergecount = 0;
			for (j=i+1; j<line.getTokenCount(); j++) {
				if ((string)line.token(i) == "*v") {
					mergecount++;
				} else {
					break;
				}
			}
			newinfo.resize(newtype.size() + 1);
			newinfo.back() = getMergedSpineInfo(sinfo, i, mergecount);
			newtype.resize(newtype.size() + 1);
			newtype.back() = datatype[i];
			i += mergecount;
		} else if ((string)line.token(i) == "*+") {
			newtype.resize(newtype.size() + 1);
			newtype.back() = datatype[i];
			newtype.resize(newtype.size() + 1);
			newtype.back() = "";
			newinfo.resize(newinfo.size() + 1);
			newinfo.back() = sinfo[i];
			newinfo.resize(newinfo.size() + 1);
			newinfo.back() = to_string(++mergecount);
		} else if ((string)line.token(i) == "*x") {
			if (i < line.getTokenCount() - 1) {
				if ((string)line.token(i) == "*x") {
					// exchange spine information
					newtype.resize(newtype.size() + 1);
					newtype.back() = datatype[i+1];
					newtype.resize(newtype.size() + 1);
					newtype.back() = datatype[i];
					newinfo.resize(newinfo.size() + 1);
					newinfo.back() = sinfo[i+1];
					newinfo.resize(newinfo.size() + 1);
					newinfo.back() = sinfo[i];
				} else {
					cerr << "ERROR in *x calculation" << endl;
					exit(1);
				}
			} else {
				cerr << "ERROR in *x calculation" << endl;
				exit(1);
			}
		} else if ((string)line.token(i) == "*-") {
			// do nothing: the spine is terminating;
		} else if (((string)line.token(i)).substr(0, 2) == "**") {
			newtype.resize(newtype.size() + 1);
			newtype.back() = line.getTokenString(i);
			newinfo.resize(newinfo.size() + 1);
			newinfo.back() = sinfo[i];
		} else {
			// should only be null interpretation, but doesn't matter
			newtype.resize(newtype.size() + 1);
			newtype.back() = datatype[i];
			newinfo.resize(newinfo.size() + 1);
			newinfo.back() = sinfo[i];
		}
	}

	datatype.resize(newtype.size());
	sinfo.resize(newinfo.size());
	for (i=0; i<newtype.size(); i++) {
		datatype[i] = newtype[i];
		sinfo[i]    = newinfo[i];
	}

	return trackcount;
}



//////////////////////////////
//
// HumdrumFile::getMergedSpineInfo -- Will only simplify a two-spine 
//   merge.  Should be expanded to larger spine mergers.
//

string HumdrumFile::getMergedSpineInfo(vector<string>& info, int starti,
		int extra) {
	string output;
	int len1;
	int len2;
	if (extra == 1) {
		len1 = info[starti].size();
		len2 = info[starti+1].size();
		if (len1 == len2) {
			if (info[starti].substr(0, len1-1) ==
					info[starti+1].substr(0,len2-1)) {	
				output = info[starti].substr(1, len1-3);
				return output;
			}
		}
		output = info[starti] + " " + info[starti+1];
		return output;
	}
	output = info[starti];
	for (int i=0; i<extra; i++) {
		output += " " + info[starti+1+extra];
	}
	return output;
}



//////////////////////////////
//
// HumdrumFile::analyzeTokenDurations -- Calculate the duration of
//   all tokens in a file.
//

bool HumdrumFile::analyzeTokenDurations (void) {
	for (int i=0; i<size(); i++) {
		if (!lines[i].analyzeTokenDurations()) {
			return false;
		}
	}
	return true;
}



//////////////////////////////
//
// HumdrumFile::analyzeRhythm -- Analyze the rhythmic structure of the 
//     data.  Returns false if there was a parse error.
//

bool HumdrumFile::analyzeRhythm(void) { 
	if (!analyzeTokenDurations()) {
		return false;
	}
	vector<HumRat> rolling;

	int i;
	for (i=0; i<size(); i++) {
		if (!lines[i].isData()) {
			continue;
		}
		/// ggg
	}

   return true;
}



//////////////////////////////
//
// operator<< -- Print a HumdrumFile.
//

ostream& operator<<(ostream& out, HumdrumFile& infile) {
	for (int i=0; i<infile.size(); i++) {
		out << infile[i] << '\n';
	}
	return out;
}


//----------------------------------------------------------------------------
// HumdrumInput -- Verovio interface to Humdrum Files.
//----------------------------------------------------------------------------


//////////////////////////////
//
// HumdrumInput::HumdrumInput --
//

HumdrumInput::HumdrumInput(Doc *doc, string filename) :
		FileInputStream(doc) {
	m_filename = filename;
}



//////////////////////////////
//
// HumdrumInput::~HumdrumInput --
//

HumdrumInput::~HumdrumInput() {
	// nothing to do.
}



////////////////////////////
//
// HumdrumInput::addKeySignature -- Parse a Humdrum key signature and
//      insert into score.  Humdrum key examples:
//         *k[]               = no sharps or flats
//         *k[f#]             = one sharp
//         *k[b-]             = one sharp
//         *k[b-e-a-d-g-c-f-] = seven sharps
//         *k[f#c#g#d#a#e#b#] = seven sharps
// The sharps/flats should go in the order they are found in the key signature,
// but this algorithm will not care about the order.  The key signature
// is presumed to contain consecutive sequence of fifths accidentals.
//
// The veriovio key signature class:
// KeySig(quantity, accid):
//    quantity : number of sharps or flats.
//    accid    : character, either: ACCIDENTAL_EXPLICIT_f for flats,
//                                  ACCIDENTAL_EXPLICIT_s for sharps.
//

void HumdrumInput::addKeySignature(Layer* layer, const string& token) {
	int quantity = 0;
	data_ACCIDENTAL_EXPLICIT accid = ACCIDENTAL_EXPLICIT_NONE;

	if (token.find('#') != string::npos) {
		accid = ACCIDENTAL_EXPLICIT_s;
		if      (token.find("b#") != string::npos) { quantity = 7; }
		else if (token.find("e#") != string::npos) { quantity = 6; }
		else if (token.find("a#") != string::npos) { quantity = 5; }
		else if (token.find("d#") != string::npos) { quantity = 4; }
		else if (token.find("g#") != string::npos) { quantity = 3; }
		else if (token.find("c#") != string::npos) { quantity = 2; }
		else if (token.find("f#") != string::npos) { quantity = 1; }
	} else if (token.find('-') != string::npos) {
		accid = ACCIDENTAL_EXPLICIT_f;
		if      (token.find("f-") != string::npos) { quantity = 7; }
		else if (token.find("c-") != string::npos) { quantity = 6; }
		else if (token.find("g-") != string::npos) { quantity = 5; }
		else if (token.find("d-") != string::npos) { quantity = 4; }
		else if (token.find("a-") != string::npos) { quantity = 3; }
		else if (token.find("e-") != string::npos) { quantity = 2; }
		else if (token.find("b-") != string::npos) { quantity = 1; }
	}

	KeySig *k = new KeySig(quantity, accid);
	layer->AddLayerElement(k);
	return;
}



//////////////////////////////
//
// HumdrumInput::parseMeter --
//

int HumdrumInput::parseMeter(int pos, const char* data) {
	return pos;
}



//////////////////////////////
//
// HumdrumInput::do_globalSpec --
//      Process the various headings: !I, !K, !N, !M
//

int HumdrumInput::do_globalSpec(int pos, const char* data) {
	return pos;
}



//////////////////////////////
//
// HumdrumInput::do_Clef --
//

int HumdrumInput::do_Clef(int pos, const char* data) {
	return pos;
}



//////////////////////////////
//
// HumdrumInput::do_Note --
//

int HumdrumInput::do_Note(int pos, const char* data, bool rest) {
return 0;
}



//////////////////////////////
//
// HumdrumInput::ImportFile --
//

bool HumdrumInput::ImportFile() {
	ifstream infile;
	infile.open(m_filename.c_str());
	bool status;
	if (m_filename.size() == 0) {
		return importStream(cin);
	} else {
		status = importStream(infile);
		if (infile.eof()) {
			infile.close();
			return true;
		}
	}
	return false;
}



//////////////////////////////
//
// HumdrumInput::ImportString --
//

bool HumdrumInput::ImportString(string data_str) {
	stringstream input;
	input << data_str;
	return importStream(input);
}



//////////////////////////////
//
// HumdrumInput::importStream -- Read Humdrum contents from an input stream.
//

bool HumdrumInput::importStream(istream& input) {
	MeiInterface mei(m_doc);
	mei.initializeScore();

	HumdrumFile infile;
	infile.read(input);
infile.printDurationInfo();
exit(1);

	return convertHumdrumToMei(infile, mei);
}



//////////////////////////////
//
// HumdrumInput::convertHumdrumToMei --
//

bool HumdrumInput::convertHumdrumToMei(HumdrumFile& infile, MeiInterface& mei) {
	for (int i=0; i<(int)infile.size(); i++) {
		i = convertMeasure(infile, mei, i);
	}
	return true;
}


//////////////////////////////
//
// HumdrumInput::convertMeasure -- Only converting first spine for now.
//

int HumdrumInput::convertMeasure(HumdrumFile& infile, MeiInterface& mei,
		int starti) {
	bool datafound = false;

	mei.addMeasure();
	mei.addStaff();

	vector<HumdrumToken> tokens;

/*
	for (int i=starti; i<infile.size(); i++) {
	}

	if (strncmp(lines[i].data(), "*k[", 3) == 0) {
		addKeySignature(layer, lines[i]);
	}
*/
return 0;

}


} // namespace vrv
