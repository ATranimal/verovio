/////////////////////////////////////////////////////////////////////////////
// Name:        iohumdrum.cpp
// Author:      Craig Stuart Sapp
// Created:     05/08/2015
// vim:         ts=3
// Copyright (c) Authors and others. All rights reserved.
/////////////////////////////////////////////////////////////////////////////


#include "iohumdrum.h"
#include <math.h>
#include <iostream>
#include <sstream>
#include <algorithm>
using namespace std;

#include "doc.h"
#include "keysig.h"
#include "layer.h"
#include "measure.h"
#include "mensur.h"
#include "page.h"
#include "note.h"
#include "rest.h"
#include "system.h"
#include "staff.h"
#include "tie.h"
#include "vrv.h"

namespace vrv {


//----------------------------------------------------------------------------
// MeiInterface -- Used to navigate the MEI data structure while converting
//                 from Humdrum data.
//----------------------------------------------------------------------------
//
// <body>        \
// |  <mdiv>     | "doc"
// |  |  <pages> /
// |  |  |  <page>
// |  |  |  |  <system>
// |  |  |  |  |  <scoreDef>
// |  |  |  |  |  |  <staffGrp>
// |  |  |  |  |  <measure>
// |  |  |  |  |  |  <staff>
// |  |  |  |  |  |  |  <layer>
//


//////////////////////////////
//
// MeiInterface::MeiInterface -- Store root document.
//   Call initializeScore() next, which will add a first page
//   and the first system on the page.
//

MeiInterface::MeiInterface(Doc* aDoc) {
	doc             = aDoc;
	staffgroup      = NULL;
	doc->Reset(Raw);
}



//////////////////////////////
//
// MeiInterface::~MeiInterface --
//

MeiInterface::~MeiInterface(void) {
	// The class does not manage memory internally.
}



//////////////////////////////
//
// MeiInterface::addPage -- Add a new page to an existing score.
//     Returns the page index which was created.
//

int MeiInterface::addPage(void) {
	if (doc) {
		Page* p = new Page();
		pages.push_back(p);
		doc->AddPage(pages.back());
		// systems is 2d: page then system on page
		// so need to update first dimension of systems:
		systems.resize(systems.size()+1);
		return pages.size();
	} else {
		cerr << "Error: cannot add page to undefined score." << endl;
		exit(1);
	}
}



//////////////////////////////
//
// MeiInterface::addSystem -- Add a new system to the current page.
//     Returns the system index on the current page which was added.
//

int MeiInterface::addSystem(void) {
	if ((pages.size() > 0) && (systems.size() > 0)) {
		System* s = new System();
		systems.back().push_back(s);
		pages.back()->AddSystem(systems.back().back());
		// prepare staff list for systems:
		systems.back().resize(systems.back().size() + 1);
		return systems.back().size();
	} else {
		cerr << "Error: cannot add system to undefined page." << endl;
		exit(1);
	}
}



//////////////////////////////
//
// MeiInterface::initializeScore -- Sets up the score and adds a
//    page and the first system on the page.
//

void MeiInterface::initializeScore(void) {
	if (getPageCount() > 0) {
		cerr << "Can only initialze the score once." << endl;
		exit(1);
	}
	createStaffGroup();
	addPage();
	addSystem();
	// Now you can do these (in this order):
	// createPart();
	// addMeasure();
	// addLayer();
}



//////////////////////////////
//
// MeiInterface::getPageCount -- Returns the current number of pages in
//     the score.
//

int MeiInterface::getPageCount(void) {
	return pages.size();
}



//////////////////////////////
//
// MeiInterface::createStaffGroup -- Add a <staffGrp> to score.
//

void MeiInterface::createStaffGroup(void) {
	if (doc) {
		staffgroup = new StaffGrp();
		doc->m_scoreDef.AddStaffGrp(staffgroup);
	} else {
		cerr << "Error: cannot add staff group to undefined score." << endl;
		exit(1);
	}
}



//////////////////////////////
//
// MeiInterface::createPart -- Add a new part which adds a new staff
//   to the current system and adds a staff definition.  Return value
//   is the part number which was added.
//

int MeiInterface::createPart(void) {
	int staffnum = staffdefinitions.size() + 1;
	if (getPageCount() != 1) {
		cerr << "Error: can only create a part when on the first page." << endl;
		exit(1);
	}
	if ((systems.size() > 0) && (systems[0].size() > 1)) {
		cerr << "Error: can only create part when at first system." << endl;
		exit(1);
	}

	if (systems.back().size() == 0) {
		// Add a new system if it has not already been done.
		// The first dimension of systems has already been updated
		// when the first page was added.
		System* sys = new System();
		systems.back().push_back(sys);
		pages.back()->AddSystem(systems.back().back());
	}

	if (doc) {
		StaffDef* sd = new StaffDef();
		sd->SetN(staffnum);
		staffdefinitions.push_back(sd);
		staffgroup->AddStaffDef(staffdefinitions.back());
	} else {
		cerr << "Error: cannot add staff to undefined score." << endl;
		exit(1);
	}
	return staffnum;
}



//////////////////////////////
//
// MeiInterface::addMeasure -- Add a measure to the current system.
//

int MeiInterface::addMeasure() {
	int measurenum = measures.size() + 1;
	Measure* m = new Measure(true, measurenum); // true = measured music
	measures.push_back(m);
	systems.back().back()->AddMeasure(measures.back());

	// Set dimension of staves: measures/staves:
	staves.resize(staves.size() + 1);

	// Set dimension of layers: measures/staves/layers:
	layers.resize(layers.size() + 1);
	return measures.size();
}



//////////////////////////////
//
// MeiInterface::addStaff -- Add a staff to the current measure.
//     Returns the staff index that was added for the current measure.
//

int MeiInterface::addStaff(void) {
	Staff* st = new Staff();
	staves.back().push_back(st);
	measures.back()->AddMeasureElement(staves.back().back());
	return staves.back().size();
}



//////////////////////////////
//
// MeiInterface::addLayer -- Add a new layer to the current staff.
//   Returns the layer index that was added to the current staff.
//

int MeiInterface::addLayer(void) {
	int layernum  = layers.back().back().size() + 1;
	Layer* layer = new Layer();
	layer->SetN(layernum);
	layers.back().back().push_back(layer);
	staves.back().back()->AddLayer(layers.back().back().back());
	return layernum;
}


} // namespace vrv
