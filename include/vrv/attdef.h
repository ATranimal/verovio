/////////////////////////////////////////////////////////////////////////////
// Name:        attdef.h
// Author:      Laurent Pugin
// Created:     2014
// Copyright (c) Authors and others. All rights reserved.
/////////////////////////////////////////////////////////////////////////////

#ifndef __VRV_ATT_DEF_H__
#define __VRV_ATT_DEF_H__

#include <string>
#include <utility>
#include <vector>

//----------------------------------------------------------------------------

#include "attclasses.h"
#include "atttypes.h"

//----------------------------------------------------------------------------

namespace vrv {

typedef std::vector<std::pair<std::string, std::string> > ArrayOfStrAttr;

#define VRV_UNSET -0x7FFFFFFF

//----------------------------------------------------------------------------
// Durations
//----------------------------------------------------------------------------

/**
 * These duration values are used for internal calculation and differ from the
 * MEI data.DURATION types (see below)
 */
#define DUR_MX -1 // maxima
#define DUR_LG 0 // longa
#define DUR_BR 1 // brevis
#define DUR_1 2 // whole note (semibrevis)
#define DUR_2 3 // half note (minima)
#define DUR_4 4 // ...
#define DUR_8 5
#define DUR_16 6
#define DUR_32 7
#define DUR_64 8
#define DUR_128 9
#define DUR_256 10 // this is it for now
// used for alignement
#define DUR_MAX 1024
// mensural duration
#define DUR_MENSURAL_OFFSET (2 * DUR_MAX)
#define DUR_MENSURAL_MASK (2 * DUR_MAX - 1)
// used for mensural alignment
#define DUR_MENSURAL_REF 1728

//----------------------------------------------------------------------------
// MEI data defines
//----------------------------------------------------------------------------

/**
 * The following defines are hand-coded and were not generated by libmei as
 * the ones in ./libmei/atttypes.h. The are generated by hand either because
 * the regroup different types (e.g., data_STEMDIRECTION), because specific
 * values are required (e.g., data_MODUSMAIOR), or because the MEI data type
 * is a pattern and not a closed list and cannot be generated automatically
 * easily (e.g., data_DURATION)
 */

/**
 * A typedef for a list of positive integer.
 * E.g., list { xsd:positiveInteger+ }
 */
typedef std::vector<data_ARTICULATION> data_ARTICULATION_List;

/**
 * MEI data.BEATRPT_REND
 */
enum data_BEATRPT_REND {
    BEATRPT_REND_NONE = 0,
    BEATRPT_REND_4,
    BEATRPT_REND_8,
    BEATRPT_REND_16,
    BEATRPT_REND_32,
    BEATRPT_REND_64,
    BEATRPT_REND_128,
    BEATRPT_REND_mixed
};

/**
 * MEI data.DURATION
 */
enum data_DURATION {
    DURATION_NONE = VRV_UNSET,
    DURATION_long = DUR_LG,
    DURATION_breve,
    DURATION_1,
    DURATION_2,
    DURATION_4,
    DURATION_8,
    DURATION_16,
    DURATION_32,
    DURATION_64,
    DURATION_128,
    DURATION_256,
    DURATION_512,
    DURATION_1024,
    DURATION_2048,
    DURATION_maxima = DUR_MX,
    DURATION_longa = DUR_MENSURAL_OFFSET + DUR_LG,
    DURATION_brevis,
    DURATION_semibrevis,
    DURATION_minima,
    DURATION_semiminima,
    DURATION_fusa,
    DURATION_semifusa
};
    
/**
 * MEI data.FONTSIZENUMERIC
 */
typedef int data_FONTSIZENUMERIC;

/**
 * MEI data.KEYSIGNATURE
 * The maximum is 255 (unsigned char)
 * Order from 7f to 7s should not be changed. This is a special case since we use abs()
 * to get the number of flats or sharps
 */
enum data_KEYSIGNATURE {
    KEYSIGNATURE_NONE = 0,
    KEYSIGNATURE_7f,
    KEYSIGNATURE_6f,
    KEYSIGNATURE_5f,
    KEYSIGNATURE_4f,
    KEYSIGNATURE_3f,
    KEYSIGNATURE_2f,
    KEYSIGNATURE_1f,
    KEYSIGNATURE_0,
    KEYSIGNATURE_1s,
    KEYSIGNATURE_2s,
    KEYSIGNATURE_3s,
    KEYSIGNATURE_4s,
    KEYSIGNATURE_5s,
    KEYSIGNATURE_6s,
    KEYSIGNATURE_7s,
    KEYSIGNATURE_mixed
};

/**
 * MEI data.MEASUREBEAT
 */
typedef std::pair<int, double> data_MEASUREBEAT;

/**
 * MEI data.MIDIBPM
 */
typedef int data_MIDIBPM;

/**
 * MEI data.MIDICHANNEL
 */
typedef int data_MIDICHANNEL;

/**
 * MEI data.MIDIMSPB
 */
typedef int data_MIDIMSPB;

/**
 * MEI data.MIDIVALUE
 */
typedef int data_MIDIVALUE;

/**
 * MEI data.MODUSMAIOR
 * NONE is -3 for perfect value (abs) by default
 */
enum data_MODUSMAIOR { MODUSMAIOR_NONE = -3, MODUSMAIOR_2 = 2, MODUSMAIOR_3 };

/**
 * MEI data.MODUSMINOR
 * NONE is -3 for perfect value (abs) by default
 */
enum data_MODUSMINOR { MODUSMINOR_NONE = -3, MODUSMINOR_2 = 2, MODUSMINOR_3 };

/**
 * MEI data.OCTAVE.DIS
 */
enum data_OCTAVE_DIS { OCTAVE_DIS_NONE = 0, OCTAVE_DIS_8 = 8, OCTAVE_DIS_15 = 15, OCTAVE_DIS_22 = 22 };

/**
 * MEI data.ORIENTATION
 */
enum data_ORIENTATION { ORIENTATION_NONE = 0, ORIENTATION_reversed, ORIENTATION_90CW, ORIENTATION_90CCW };

/**
 * MEI data.PERCENT
 */
typedef int data_PERCENT;

/**
 * MEI data.PITCHNAME
 */
enum data_PITCHNAME {
    PITCHNAME_NONE = 0,
    PITCHNAME_c,
    PITCHNAME_d,
    PITCHNAME_e,
    PITCHNAME_f,
    PITCHNAME_g,
    PITCHNAME_a,
    PITCHNAME_b,
};

/**
 * MEI data.PITCHNAME.GES
 */
enum data_PITCHNAME_GES {
    PITCHNAME_GES_NONE = 0,
    PITCHNAME_GES_c,
    PITCHNAME_GES_d,
    PITCHNAME_GES_e,
    PITCHNAME_GES_f,
    PITCHNAME_GES_g,
    PITCHNAME_GES_a,
    PITCHNAME_GES_b,
    PITCHNAME_GES_none
};

/**
 * MEI data.PROLATIO
 * NONE is -3 for perfect value (abs) by default
 */
enum data_PROLATIO { PROLATIO_NONE = -3, PROLATIO_2 = 2, PROLATIO_3 };

/**
 * MEI data.STEMDIRECTION
 */
enum data_STEMDIRECTION {
    STEMDIRECTION_NONE = 0,
    STEMDIRECTION_up,
    STEMDIRECTION_down,
    STEMDIRECTION_left,
    STEMDIRECTION_right,
    STEMDIRECTION_ne,
    STEMDIRECTION_se,
    STEMDIRECTION_nw,
    STEMDIRECTION_sw,
};

/**
 * MEI data.TIE
 */
enum data_TIE { TIE_NONE = 0, TIE_i, TIE_m, TIE_t };

/**
 * MEI data.TEMPUS
 * NONE is -3 for perfect value (abs) by default
 */
enum data_TEMPUS { TEMPUS_NONE = -3, TEMPUS_2 = 2, TEMPUS_3 };

/**
 * A typedef for a list of positive integer.
 * E.g., list { xsd:positiveInteger+ }
 */
typedef std::vector<int> xsdPositiveInteger_List;

//----------------------------------------------------------------------------
// Alternate data types not generated by LibMEI
//----------------------------------------------------------------------------

/**
 * MEI data.FONTSIZE
 * Since it can contain different subtype we need a dedicated class for it.
 */

enum FontSizeType { FONTSIZE_NONE = 0, FONTSIZE_fontSizeNumeric, FONTSIZE_term, FONTSIZE_percent };

class data_FONTSIZE {
public:
    data_FONTSIZE()
    {
        m_type = FONTSIZE_NONE;
        m_fontSizeNumeric = VRV_UNSET;
        m_term = FONTSIZETERM_NONE;
        m_percent = 0;
    }
    virtual ~data_FONTSIZE() {}
    
    FontSizeType GetType() const { return m_type; }
    
    data_FONTSIZENUMERIC GetFontSizeNumeric() const { return m_fontSizeNumeric; }
    void SetFontSizeNumeric(data_FONTSIZENUMERIC value) { m_fontSizeNumeric = value; }
    
    data_FONTSIZETERM GetTerm() const { return m_term; }
    void SetTerm(data_FONTSIZETERM value) { m_term = value; }
    
    data_PERCENT GetPercent() const { return m_percent; }
    void SetPercent(data_PERCENT value) { m_percent = value; }
    
    // comparison
    bool operator==(const data_FONTSIZE &val) const
    {
        if (m_type != val.GetType()) return false;
        if (m_fontSizeNumeric != val.GetFontSizeNumeric()) return false;
        if (m_term != val.GetTerm()) return false;
        if (m_percent != val.GetPercent()) return false;
        return true;
    }
    bool operator!=(const data_FONTSIZE &val) const { return !(*this == val); }
    
protected:
    FontSizeType m_type;
    data_FONTSIZENUMERIC m_fontSizeNumeric;
    data_FONTSIZETERM m_term;
    data_PERCENT m_percent;
};

/**
 * MEI data.STAFFITEM
 * Since it can contain different subtype we need a dedicated class for it.
 */

enum StaffItemType { STAFFITEM_NONE = 0, STAFFITEM_basic, STAFFITEM_cmn, STAFFITEM_mensural };

class data_STAFFITEM {
public:
    data_STAFFITEM()
    {
        m_type = STAFFITEM_NONE;
        m_basic = STAFFITEM_basic_NONE;
        m_cmn = STAFFITEM_cmn_NONE;
        m_mensural = STAFFITEM_mensural_NONE;
    }
    virtual ~data_STAFFITEM() {}
    
    StaffItemType GetType() const { return m_type; }
    
    data_STAFFITEM_basic GetBasic() const { return m_basic; }
    void SetBasic(data_STAFFITEM_basic value) { m_basic = value; }
    
    data_STAFFITEM_cmn GetCmn() const { return m_cmn; }
    void SetCmn(data_STAFFITEM_cmn value) { m_cmn = value; }
    
    data_STAFFITEM_mensural GetMensural() const { return m_mensural; }
    void SetMensural(data_STAFFITEM_mensural value) { m_mensural = value; }
    
    // comparison
    bool operator==(const data_STAFFITEM &val) const
    {
        if (m_type != val.GetType()) return false;
        if (m_basic != val.GetBasic()) return false;
        if (m_cmn != val.GetCmn()) return false;
        if (m_mensural != val.GetMensural()) return false;
        return true;
    }
    bool operator!=(const data_STAFFITEM &val) const { return !(*this == val); }
    
protected:
    StaffItemType m_type;
    data_STAFFITEM_basic m_basic;
    data_STAFFITEM_cmn m_cmn;
    data_STAFFITEM_mensural m_mensural;
};
    
/**
 * MEI data.STAFFREL
 * Since it can contain different subtype we need a dedicated class for it.
 */

enum StaffRelType { STAFFREL_NONE = 0, STAFFREL_basic, STAFFREL_extended };

class data_STAFFREL {
public:
    data_STAFFREL()
    {
        m_type = STAFFREL_NONE;
        m_basic = STAFFREL_basic_NONE;
        m_extended = STAFFREL_extended_NONE;
    }
    virtual ~data_STAFFREL() {}
    
    StaffRelType GetType() const { return m_type; }
    
    data_STAFFREL_basic GetBasic() const { return m_basic; }
    void SetBasic(data_STAFFREL_basic value) { m_basic = value; }
    
    data_STAFFREL_extended GetExtended() const { return m_extended; }
    void SetExtended(data_STAFFREL_extended value) { m_extended = value; }
    
    // comparison
    bool operator==(const data_STAFFREL &val) const
    {
        if (m_type != val.GetType()) return false;
        if (m_basic != val.GetBasic()) return false;
        if (m_extended != val.GetExtended()) return false;
        return true;
    }
    bool operator!=(const data_STAFFREL &val) const { return !(*this == val); }
    
protected:
    StaffRelType m_type;
    data_STAFFREL_basic m_basic;
    data_STAFFREL_extended m_extended;
};
  
    


} // namespace vrv

#endif // __VRV_ATT_DEF_H__
