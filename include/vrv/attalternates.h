/////////////////////////////////////////////////////////////////////////////
// Name:        attalternates.h
// Author:      Laurent Pugin
// Created:     2017
// Copyright (c) Authors and others. All rights reserved.
/////////////////////////////////////////////////////////////////////////////

#ifndef __VRV_ATT_ALTERNATES_H__
#define __VRV_ATT_ALTERNATES_H__

#include <string>

//----------------------------------------------------------------------------

#include "vrvdef.h"

namespace vrv {

//----------------------------------------------------------------------------
// Alternate data types not generated by LibMEI
//----------------------------------------------------------------------------

/**
 * MEI data.FONTSIZE
 * Since it can contain different subtype we need a dedicated class for it.
 */

enum FontSizeType { FONTSIZE_NONE = 0, FONTSIZE_fontSizeNumeric, FONTSIZE_term, FONTSIZE_percent };

class data_FONTSIZE {
public:
    data_FONTSIZE()
    {
        m_type = FONTSIZE_NONE;
        m_fontSizeNumeric = VRV_UNSET;
        m_term = FONTSIZETERM_NONE;
        m_percent = 0;
    }
    virtual ~data_FONTSIZE() {}
    
    FontSizeType GetType() const { return m_type; }
    
    data_FONTSIZENUMERIC GetFontSizeNumeric() const { return m_fontSizeNumeric; }
    void SetFontSizeNumeric(data_FONTSIZENUMERIC value) { m_fontSizeNumeric = value; }
    
    data_FONTSIZETERM GetTerm() const { return m_term; }
    void SetTerm(data_FONTSIZETERM value) { m_term = value; }
    
    data_PERCENT GetPercent() const { return m_percent; }
    void SetPercent(data_PERCENT value) { m_percent = value; }
    
    // comparison
    bool operator==(const data_FONTSIZE &val) const
    {
        if (m_type != val.GetType()) return false;
        if (m_fontSizeNumeric != val.GetFontSizeNumeric()) return false;
        if (m_term != val.GetTerm()) return false;
        if (m_percent != val.GetPercent()) return false;
        return true;
    }
    bool operator!=(const data_FONTSIZE &val) const { return !(*this == val); }
    
protected:
    FontSizeType m_type;
    data_FONTSIZENUMERIC m_fontSizeNumeric;
    data_FONTSIZETERM m_term;
    data_PERCENT m_percent;
};

/**
 * MEI data.STAFFITEM
 * Since it can contain different subtype we need a dedicated class for it.
 */

enum StaffItemType { STAFFITEM_NONE = 0, STAFFITEM_basic, STAFFITEM_cmn, STAFFITEM_mensural };

class data_STAFFITEM {
public:
    data_STAFFITEM()
    {
        m_type = STAFFITEM_NONE;
        m_basic = STAFFITEM_basic_NONE;
        m_cmn = STAFFITEM_cmn_NONE;
        m_mensural = STAFFITEM_mensural_NONE;
    }
    virtual ~data_STAFFITEM() {}
    
    StaffItemType GetType() const { return m_type; }
    
    data_STAFFITEM_basic GetBasic() const { return m_basic; }
    void SetBasic(data_STAFFITEM_basic value) { m_basic = value; }
    
    data_STAFFITEM_cmn GetCmn() const { return m_cmn; }
    void SetCmn(data_STAFFITEM_cmn value) { m_cmn = value; }
    
    data_STAFFITEM_mensural GetMensural() const { return m_mensural; }
    void SetMensural(data_STAFFITEM_mensural value) { m_mensural = value; }
    
    // comparison
    bool operator==(const data_STAFFITEM &val) const
    {
        if (m_type != val.GetType()) return false;
        if (m_basic != val.GetBasic()) return false;
        if (m_cmn != val.GetCmn()) return false;
        if (m_mensural != val.GetMensural()) return false;
        return true;
    }
    bool operator!=(const data_STAFFITEM &val) const { return !(*this == val); }
    
protected:
    StaffItemType m_type;
    data_STAFFITEM_basic m_basic;
    data_STAFFITEM_cmn m_cmn;
    data_STAFFITEM_mensural m_mensural;
};
    
/**
 * MEI data.STAFFREL
 * Since it can contain different subtype we need a dedicated class for it.
 */

enum StaffRelType { STAFFREL_NONE = 0, STAFFREL_basic, STAFFREL_extended };

class data_STAFFREL {
public:
    data_STAFFREL() { Reset(STAFFREL_NONE); }
    virtual ~data_STAFFREL() {}
    
    void Reset(StaffRelType type) {
        m_type = type;
        m_basic = STAFFREL_basic_NONE;
        m_extended = STAFFREL_extended_NONE;
    }
    
    StaffRelType GetType() const { return m_type; }
    
    data_STAFFREL_basic GetBasic() const { return m_basic; }
    void SetBasic(data_STAFFREL_basic value) { Reset(STAFFREL_basic); m_basic = value; }
    
    data_STAFFREL_extended GetExtended() const { return m_extended; }
    void SetExtended(data_STAFFREL_extended value) { Reset(STAFFREL_extended); m_extended = value; }
    
    bool HasValue() const {
        if (m_basic != STAFFREL_basic_NONE) return true;
        if (m_extended != STAFFREL_extended_NONE) return true;
        return false;
    }
    
    // comparison
    bool operator==(const data_STAFFREL &val) const
    {
        if (m_type != val.GetType()) return false;
        if (m_basic != val.GetBasic()) return false;
        if (m_extended != val.GetExtended()) return false;
        return true;
    }
    bool operator!=(const data_STAFFREL &val) const { return !(*this == val); }
    
protected:
    StaffRelType m_type;
    data_STAFFREL_basic m_basic;
    data_STAFFREL_extended m_extended;
};
 
//----------------------------------------------------------------------------
// Alternate data types unsing other alternate data types (above)
//----------------------------------------------------------------------------
   
/**
 * MEI data.PLACEMENT
 * Since it can contain different subtype we need a dedicated class for it.
 */

enum PlacementType { PLACEMENT_NONE = 0, PLACEMENT_staffRel, PLACEMENT_nonStaffPlace, PLACEMENT_nmtoken };

class data_PLACEMENT {
public:
    data_PLACEMENT()
    {
        m_type = PLACEMENT_NONE;
        m_staffRel = data_STAFFREL();
        m_nonStaffPlace = NONSTAFFPLACE_NONE;
        m_nmtoken = "";
    }
    virtual ~data_PLACEMENT() {}
    
    PlacementType GetType() const { return m_type; }
    
    data_STAFFREL GetStaffRel() const { return m_staffRel; }
    void SetStaffRel(data_STAFFREL value) { m_staffRel = value; }
    data_STAFFREL *GetStaffRelAtlernate() { return &m_staffRel; }

    data_NONSTAFFPLACE GetNonStaffPlace() const { return m_nonStaffPlace; }
    void SetNonStaffPlace(data_NONSTAFFPLACE value) { m_nonStaffPlace = value; }
    
    std::string GetNMToken() const { return m_nmtoken; }
    void SetNMToken(std::string value) { m_nmtoken = value; }
    
    bool HasValue() const {
        if (m_staffRel.HasValue()) return true;
        if (m_nonStaffPlace != NONSTAFFPLACE_NONE) return true;
        if (m_nmtoken != "") return true;
        return false;
    }
    
    // comparison
    bool operator==(const data_PLACEMENT &val) const
    {
        if (m_type != val.GetType()) return false;
        if (m_staffRel != val.GetStaffRel()) return false;
        if (m_nonStaffPlace != val.GetNonStaffPlace()) return false;
        if (m_nmtoken != val.GetNMToken()) return false;
        return true;
    }
    bool operator!=(const data_PLACEMENT &val) const { return !(*this == val); }
    
protected:
    PlacementType m_type;
    data_STAFFREL m_staffRel;
    data_NONSTAFFPLACE m_nonStaffPlace;
    std::string m_nmtoken;
};

} // namespace vrv

#endif
